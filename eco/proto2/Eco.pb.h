// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Eco.proto

#ifndef PROTOBUF_Eco_2eproto__INCLUDED
#define PROTOBUF_Eco_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eco {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Eco_2eproto();
void protobuf_AssignDesc_Eco_2eproto();
void protobuf_ShutdownFile_Eco_2eproto();

class Word;
class Error;
class Language;
class Locale;
class GetLangReq;
class GetLicenseRsp;
class Function;
class Role;
class Logging;
class Subscribe;
class Remove;
class Property;
class Datatype;

// ===================================================================

class Word : public ::google::protobuf::Message {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Word& default_instance();

  void Swap(Word* other);

  // implements Message ----------------------------------------------

  Word* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:eco.proto.Word)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Word* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:eco.proto.Error)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::std::string* value_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Language : public ::google::protobuf::Message {
 public:
  Language();
  virtual ~Language();

  Language(const Language& from);

  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Language& default_instance();

  void Swap(Language* other);

  // implements Message ----------------------------------------------

  Language* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated .eco.proto.Word word = 8;
  inline int word_size() const;
  inline void clear_word();
  static const int kWordFieldNumber = 8;
  inline const ::eco::proto::Word& word(int index) const;
  inline ::eco::proto::Word* mutable_word(int index);
  inline ::eco::proto::Word* add_word();
  inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Word >&
      word() const;
  inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Word >*
      mutable_word();

  // repeated .eco.proto.Error error = 9;
  inline int error_size() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline const ::eco::proto::Error& error(int index) const;
  inline ::eco::proto::Error* mutable_error(int index);
  inline ::eco::proto::Error* add_error();
  inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Error >&
      error() const;
  inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Error >*
      mutable_error();

  // @@protoc_insertion_point(class_scope:eco.proto.Language)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* version_;
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::eco::proto::Word > word_;
  ::google::protobuf::RepeatedPtrField< ::eco::proto::Error > error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Language* default_instance_;
};
// -------------------------------------------------------------------

class Locale : public ::google::protobuf::Message {
 public:
  Locale();
  virtual ~Locale();

  Locale(const Locale& from);

  inline Locale& operator=(const Locale& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Locale& default_instance();

  void Swap(Locale* other);

  // implements Message ----------------------------------------------

  Locale* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Locale& from);
  void MergeFrom(const Locale& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string default = 1;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 1;
  inline const ::std::string& default_() const;
  inline void set_default_(const ::std::string& value);
  inline void set_default_(const char* value);
  inline void set_default_(const char* value, size_t size);
  inline ::std::string* mutable_default_();
  inline ::std::string* release_default_();
  inline void set_allocated_default_(::std::string* default_);

  // repeated .eco.proto.Language lang = 9;
  inline int lang_size() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 9;
  inline const ::eco::proto::Language& lang(int index) const;
  inline ::eco::proto::Language* mutable_lang(int index);
  inline ::eco::proto::Language* add_lang();
  inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Language >&
      lang() const;
  inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Language >*
      mutable_lang();

  // @@protoc_insertion_point(class_scope:eco.proto.Locale)
 private:
  inline void set_has_default_();
  inline void clear_has_default_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* default__;
  ::google::protobuf::RepeatedPtrField< ::eco::proto::Language > lang_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Locale* default_instance_;
};
// -------------------------------------------------------------------

class GetLangReq : public ::google::protobuf::Message {
 public:
  GetLangReq();
  virtual ~GetLangReq();

  GetLangReq(const GetLangReq& from);

  inline GetLangReq& operator=(const GetLangReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLangReq& default_instance();

  void Swap(GetLangReq* other);

  // implements Message ----------------------------------------------

  GetLangReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLangReq& from);
  void MergeFrom(const GetLangReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const char* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // optional string lang = 2;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 2;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // @@protoc_insertion_point(class_scope:eco.proto.GetLangReq)
 private:
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_lang();
  inline void clear_has_lang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* module_;
  ::std::string* lang_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static GetLangReq* default_instance_;
};
// -------------------------------------------------------------------

class GetLicenseRsp : public ::google::protobuf::Message {
 public:
  GetLicenseRsp();
  virtual ~GetLicenseRsp();

  GetLicenseRsp(const GetLicenseRsp& from);

  inline GetLicenseRsp& operator=(const GetLicenseRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLicenseRsp& default_instance();

  void Swap(GetLicenseRsp* other);

  // implements Message ----------------------------------------------

  GetLicenseRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLicenseRsp& from);
  void MergeFrom(const GetLicenseRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const char* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // optional string lang = 2;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 2;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // optional string license = 4;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 4;
  inline const ::std::string& license() const;
  inline void set_license(const ::std::string& value);
  inline void set_license(const char* value);
  inline void set_license(const char* value, size_t size);
  inline ::std::string* mutable_license();
  inline ::std::string* release_license();
  inline void set_allocated_license(::std::string* license);

  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:eco.proto.GetLicenseRsp)
 private:
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_lang();
  inline void clear_has_lang();
  inline void set_has_license();
  inline void clear_has_license();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* module_;
  ::std::string* lang_;
  ::std::string* license_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static GetLicenseRsp* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  Function* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::uint64 parent() const;
  inline void set_parent(::google::protobuf::uint64 value);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string detail = 5;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 5;
  inline const ::std::string& detail() const;
  inline void set_detail(const ::std::string& value);
  inline void set_detail(const char* value);
  inline void set_detail(const char* value, size_t size);
  inline ::std::string* mutable_detail();
  inline ::std::string* release_detail();
  inline void set_allocated_detail(::std::string* detail);

  // @@protoc_insertion_point(class_scope:eco.proto.Function)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_detail();
  inline void clear_has_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 parent_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .eco.proto.Function func = 10;
  inline int func_size() const;
  inline void clear_func();
  static const int kFuncFieldNumber = 10;
  inline const ::eco::proto::Function& func(int index) const;
  inline ::eco::proto::Function* mutable_func(int index);
  inline ::eco::proto::Function* add_func();
  inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Function >&
      func() const;
  inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Function >*
      mutable_func();

  // @@protoc_insertion_point(class_scope:eco.proto.Role)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::eco::proto::Function > func_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class Logging : public ::google::protobuf::Message {
 public:
  Logging();
  virtual ~Logging();

  Logging(const Logging& from);

  inline Logging& operator=(const Logging& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logging& default_instance();

  void Swap(Logging* other);

  // implements Message ----------------------------------------------

  Logging* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logging& from);
  void MergeFrom(const Logging& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string mac = 5;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 5;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional uint32 action = 8;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 8;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // optional uint64 object = 9;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 9;
  inline ::google::protobuf::uint64 object() const;
  inline void set_object(::google::protobuf::uint64 value);

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 11;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 11;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string detail = 12;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 12;
  inline const ::std::string& detail() const;
  inline void set_detail(const ::std::string& value);
  inline void set_detail(const char* value);
  inline void set_detail(const char* value, size_t size);
  inline ::std::string* mutable_detail();
  inline ::std::string* release_detail();
  inline void set_allocated_detail(::std::string* detail);

  // @@protoc_insertion_point(class_scope:eco.proto.Logging)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_detail();
  inline void clear_has_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* user_;
  ::std::string* time_;
  ::std::string* ip_;
  ::std::string* mac_;
  ::google::protobuf::uint64 object_;
  ::std::string* name_;
  ::std::string* value_;
  ::std::string* detail_;
  ::google::protobuf::uint32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Logging* default_instance_;
};
// -------------------------------------------------------------------

class Subscribe : public ::google::protobuf::Message {
 public:
  Subscribe();
  virtual ~Subscribe();

  Subscribe(const Subscribe& from);

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Subscribe& default_instance();

  void Swap(Subscribe* other);

  // implements Message ----------------------------------------------

  Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint64 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);

  // optional string topic = 4;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 4;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:eco.proto.Subscribe)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::uint64 value_;
  ::std::string* topic_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class Remove : public ::google::protobuf::Message {
 public:
  Remove();
  virtual ~Remove();

  Remove(const Remove& from);

  inline Remove& operator=(const Remove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Remove& default_instance();

  void Swap(Remove* other);

  // implements Message ----------------------------------------------

  Remove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Remove& from);
  void MergeFrom(const Remove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional uint64 object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline ::google::protobuf::uint64 object() const;
  inline void set_object(::google::protobuf::uint64 value);

  // optional string entity = 5;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 5;
  inline const ::std::string& entity() const;
  inline void set_entity(const ::std::string& value);
  inline void set_entity(const char* value);
  inline void set_entity(const char* value, size_t size);
  inline ::std::string* mutable_entity();
  inline ::std::string* release_entity();
  inline void set_allocated_entity(::std::string* entity);

  // @@protoc_insertion_point(class_scope:eco.proto.Remove)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::uint64 object_;
  ::std::string* entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Remove* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  void Swap(Property* other);

  // implements Message ----------------------------------------------

  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional uint64 object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline ::google::protobuf::uint64 object() const;
  inline void set_object(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string entity = 5;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 5;
  inline const ::std::string& entity() const;
  inline void set_entity(const ::std::string& value);
  inline void set_entity(const char* value);
  inline void set_entity(const char* value, size_t size);
  inline ::std::string* mutable_entity();
  inline ::std::string* release_entity();
  inline void set_allocated_entity(::std::string* entity);

  // @@protoc_insertion_point(class_scope:eco.proto.Property)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::uint64 object_;
  ::std::string* name_;
  ::std::string* value_;
  ::std::string* entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Datatype : public ::google::protobuf::Message {
 public:
  Datatype();
  virtual ~Datatype();

  Datatype(const Datatype& from);

  inline Datatype& operator=(const Datatype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datatype& default_instance();

  void Swap(Datatype* other);

  // implements Message ----------------------------------------------

  Datatype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datatype& from);
  void MergeFrom(const Datatype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 11;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string value = 12;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 12;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string range = 13;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 13;
  inline const ::std::string& range() const;
  inline void set_range(const ::std::string& value);
  inline void set_range(const char* value);
  inline void set_range(const char* value, size_t size);
  inline ::std::string* mutable_range();
  inline ::std::string* release_range();
  inline void set_allocated_range(::std::string* range);

  // optional string detail = 14;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 14;
  inline const ::std::string& detail() const;
  inline void set_detail(const ::std::string& value);
  inline void set_detail(const char* value);
  inline void set_detail(const char* value, size_t size);
  inline ::std::string* mutable_detail();
  inline ::std::string* release_detail();
  inline void set_allocated_detail(::std::string* detail);

  // @@protoc_insertion_point(class_scope:eco.proto.Datatype)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_detail();
  inline void clear_has_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  ::std::string* range_;
  ::std::string* detail_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Eco_2eproto();
  friend void protobuf_AssignDesc_Eco_2eproto();
  friend void protobuf_ShutdownFile_Eco_2eproto();

  void InitAsDefaultInstance();
  static Datatype* default_instance_;
};
// ===================================================================


// ===================================================================

// Word

// optional string path = 1;
inline bool Word::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Word::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Word::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Word::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Word::path() const {
  return *path_;
}
inline void Word::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Word::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Word::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Word::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Word::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Word::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool Word::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Word::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Word::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Word::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Word::value() const {
  return *value_;
}
inline void Word::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Word::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Word::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Word::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Word::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Word::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Error

// optional int32 id = 1;
inline bool Error::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Error::id() const {
  return id_;
}
inline void Error::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string path = 2;
inline bool Error::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Error::path() const {
  return *path_;
}
inline void Error::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Error::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Error::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Error::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Error::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 3;
inline bool Error::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Error::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Error::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Error::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Error::value() const {
  return *value_;
}
inline void Error::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Error::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Error::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Error::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Error::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Language

// optional string name = 1;
inline bool Language::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Language::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Language::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Language::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Language::name() const {
  return *name_;
}
inline void Language::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Language::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Language::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Language::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Language::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Language::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 2;
inline bool Language::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Language::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Language::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Language::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Language::version() const {
  return *version_;
}
inline void Language::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Language::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Language::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Language::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* Language::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Language::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool Language::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Language::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Language::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Language::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Language::path() const {
  return *path_;
}
inline void Language::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Language::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Language::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Language::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Language::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Language::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .eco.proto.Word word = 8;
inline int Language::word_size() const {
  return word_.size();
}
inline void Language::clear_word() {
  word_.Clear();
}
inline const ::eco::proto::Word& Language::word(int index) const {
  return word_.Get(index);
}
inline ::eco::proto::Word* Language::mutable_word(int index) {
  return word_.Mutable(index);
}
inline ::eco::proto::Word* Language::add_word() {
  return word_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Word >&
Language::word() const {
  return word_;
}
inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Word >*
Language::mutable_word() {
  return &word_;
}

// repeated .eco.proto.Error error = 9;
inline int Language::error_size() const {
  return error_.size();
}
inline void Language::clear_error() {
  error_.Clear();
}
inline const ::eco::proto::Error& Language::error(int index) const {
  return error_.Get(index);
}
inline ::eco::proto::Error* Language::mutable_error(int index) {
  return error_.Mutable(index);
}
inline ::eco::proto::Error* Language::add_error() {
  return error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Error >&
Language::error() const {
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Error >*
Language::mutable_error() {
  return &error_;
}

// -------------------------------------------------------------------

// Locale

// optional string default = 1;
inline bool Locale::has_default_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Locale::set_has_default_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Locale::clear_has_default_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Locale::clear_default_() {
  if (default__ != &::google::protobuf::internal::kEmptyString) {
    default__->clear();
  }
  clear_has_default_();
}
inline const ::std::string& Locale::default_() const {
  return *default__;
}
inline void Locale::set_default_(const ::std::string& value) {
  set_has_default_();
  if (default__ == &::google::protobuf::internal::kEmptyString) {
    default__ = new ::std::string;
  }
  default__->assign(value);
}
inline void Locale::set_default_(const char* value) {
  set_has_default_();
  if (default__ == &::google::protobuf::internal::kEmptyString) {
    default__ = new ::std::string;
  }
  default__->assign(value);
}
inline void Locale::set_default_(const char* value, size_t size) {
  set_has_default_();
  if (default__ == &::google::protobuf::internal::kEmptyString) {
    default__ = new ::std::string;
  }
  default__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Locale::mutable_default_() {
  set_has_default_();
  if (default__ == &::google::protobuf::internal::kEmptyString) {
    default__ = new ::std::string;
  }
  return default__;
}
inline ::std::string* Locale::release_default_() {
  clear_has_default_();
  if (default__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default__;
    default__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Locale::set_allocated_default_(::std::string* default_) {
  if (default__ != &::google::protobuf::internal::kEmptyString) {
    delete default__;
  }
  if (default_) {
    set_has_default_();
    default__ = default_;
  } else {
    clear_has_default_();
    default__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .eco.proto.Language lang = 9;
inline int Locale::lang_size() const {
  return lang_.size();
}
inline void Locale::clear_lang() {
  lang_.Clear();
}
inline const ::eco::proto::Language& Locale::lang(int index) const {
  return lang_.Get(index);
}
inline ::eco::proto::Language* Locale::mutable_lang(int index) {
  return lang_.Mutable(index);
}
inline ::eco::proto::Language* Locale::add_lang() {
  return lang_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Language >&
Locale::lang() const {
  return lang_;
}
inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Language >*
Locale::mutable_lang() {
  return &lang_;
}

// -------------------------------------------------------------------

// GetLangReq

// optional string module = 1;
inline bool GetLangReq::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLangReq::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLangReq::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLangReq::clear_module() {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& GetLangReq::module() const {
  return *module_;
}
inline void GetLangReq::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void GetLangReq::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void GetLangReq::set_module(const char* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLangReq::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  return module_;
}
inline ::std::string* GetLangReq::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLangReq::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lang = 2;
inline bool GetLangReq::has_lang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLangReq::set_has_lang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLangReq::clear_has_lang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLangReq::clear_lang() {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& GetLangReq::lang() const {
  return *lang_;
}
inline void GetLangReq::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void GetLangReq::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void GetLangReq::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLangReq::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  return lang_;
}
inline ::std::string* GetLangReq::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLangReq::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetLicenseRsp

// optional string module = 1;
inline bool GetLicenseRsp::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLicenseRsp::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLicenseRsp::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLicenseRsp::clear_module() {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& GetLicenseRsp::module() const {
  return *module_;
}
inline void GetLicenseRsp::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void GetLicenseRsp::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void GetLicenseRsp::set_module(const char* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLicenseRsp::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  return module_;
}
inline ::std::string* GetLicenseRsp::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLicenseRsp::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lang = 2;
inline bool GetLicenseRsp::has_lang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLicenseRsp::set_has_lang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLicenseRsp::clear_has_lang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLicenseRsp::clear_lang() {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& GetLicenseRsp::lang() const {
  return *lang_;
}
inline void GetLicenseRsp::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void GetLicenseRsp::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void GetLicenseRsp::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLicenseRsp::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  return lang_;
}
inline ::std::string* GetLicenseRsp::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLicenseRsp::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string license = 4;
inline bool GetLicenseRsp::has_license() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLicenseRsp::set_has_license() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLicenseRsp::clear_has_license() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLicenseRsp::clear_license() {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    license_->clear();
  }
  clear_has_license();
}
inline const ::std::string& GetLicenseRsp::license() const {
  return *license_;
}
inline void GetLicenseRsp::set_license(const ::std::string& value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void GetLicenseRsp::set_license(const char* value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(value);
}
inline void GetLicenseRsp::set_license(const char* value, size_t size) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  license_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLicenseRsp::mutable_license() {
  set_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    license_ = new ::std::string;
  }
  return license_;
}
inline ::std::string* GetLicenseRsp::release_license() {
  clear_has_license();
  if (license_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_;
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLicenseRsp::set_allocated_license(::std::string* license) {
  if (license_ != &::google::protobuf::internal::kEmptyString) {
    delete license_;
  }
  if (license) {
    set_has_license();
    license_ = license;
  } else {
    clear_has_license();
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 5;
inline bool GetLicenseRsp::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLicenseRsp::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLicenseRsp::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLicenseRsp::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetLicenseRsp::version() const {
  return *version_;
}
inline void GetLicenseRsp::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLicenseRsp::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLicenseRsp::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLicenseRsp::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetLicenseRsp::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetLicenseRsp::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Function

// optional uint64 id = 1;
inline bool Function::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Function::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Function::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Function::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Function::id() const {
  return id_;
}
inline void Function::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 parent = 2;
inline bool Function::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Function::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Function::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Function::clear_parent() {
  parent_ = GOOGLE_ULONGLONG(0);
  clear_has_parent();
}
inline ::google::protobuf::uint64 Function::parent() const {
  return parent_;
}
inline void Function::set_parent(::google::protobuf::uint64 value) {
  set_has_parent();
  parent_ = value;
}

// optional string path = 3;
inline bool Function::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Function::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Function::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Function::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Function::path() const {
  return *path_;
}
inline void Function::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Function::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Function::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Function::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Function::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool Function::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Function::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Function::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Function::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Function::name() const {
  return *name_;
}
inline void Function::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Function::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Function::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string detail = 5;
inline bool Function::has_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Function::set_has_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Function::clear_has_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Function::clear_detail() {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    detail_->clear();
  }
  clear_has_detail();
}
inline const ::std::string& Function::detail() const {
  return *detail_;
}
inline void Function::set_detail(const ::std::string& value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Function::set_detail(const char* value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Function::set_detail(const char* value, size_t size) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_detail() {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  return detail_;
}
inline ::std::string* Function::release_detail() {
  clear_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_;
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Function::set_allocated_detail(::std::string* detail) {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    delete detail_;
  }
  if (detail) {
    set_has_detail();
    detail_ = detail;
  } else {
    clear_has_detail();
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Role

// optional uint64 id = 1;
inline bool Role::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Role::id() const {
  return id_;
}
inline void Role::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  return *name_;
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Role::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .eco.proto.Function func = 10;
inline int Role::func_size() const {
  return func_.size();
}
inline void Role::clear_func() {
  func_.Clear();
}
inline const ::eco::proto::Function& Role::func(int index) const {
  return func_.Get(index);
}
inline ::eco::proto::Function* Role::mutable_func(int index) {
  return func_.Mutable(index);
}
inline ::eco::proto::Function* Role::add_func() {
  return func_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eco::proto::Function >&
Role::func() const {
  return func_;
}
inline ::google::protobuf::RepeatedPtrField< ::eco::proto::Function >*
Role::mutable_func() {
  return &func_;
}

// -------------------------------------------------------------------

// Logging

// optional uint64 id = 1;
inline bool Logging::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logging::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logging::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logging::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Logging::id() const {
  return id_;
}
inline void Logging::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string user = 2;
inline bool Logging::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Logging::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Logging::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Logging::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Logging::user() const {
  return *user_;
}
inline void Logging::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Logging::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Logging::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Logging::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 3;
inline bool Logging::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Logging::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Logging::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Logging::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Logging::time() const {
  return *time_;
}
inline void Logging::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Logging::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Logging::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* Logging::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 4;
inline bool Logging::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Logging::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Logging::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Logging::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Logging::ip() const {
  return *ip_;
}
inline void Logging::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Logging::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Logging::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Logging::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac = 5;
inline bool Logging::has_mac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Logging::set_has_mac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Logging::clear_has_mac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Logging::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& Logging::mac() const {
  return *mac_;
}
inline void Logging::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void Logging::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void Logging::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* Logging::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 action = 8;
inline bool Logging::has_action() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Logging::set_has_action() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Logging::clear_has_action() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Logging::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 Logging::action() const {
  return action_;
}
inline void Logging::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// optional uint64 object = 9;
inline bool Logging::has_object() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Logging::set_has_object() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Logging::clear_has_object() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Logging::clear_object() {
  object_ = GOOGLE_ULONGLONG(0);
  clear_has_object();
}
inline ::google::protobuf::uint64 Logging::object() const {
  return object_;
}
inline void Logging::set_object(::google::protobuf::uint64 value) {
  set_has_object();
  object_ = value;
}

// optional string name = 10;
inline bool Logging::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Logging::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Logging::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Logging::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Logging::name() const {
  return *name_;
}
inline void Logging::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Logging::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Logging::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Logging::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 11;
inline bool Logging::has_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Logging::set_has_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Logging::clear_has_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Logging::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Logging::value() const {
  return *value_;
}
inline void Logging::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Logging::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Logging::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Logging::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string detail = 12;
inline bool Logging::has_detail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Logging::set_has_detail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Logging::clear_has_detail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Logging::clear_detail() {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    detail_->clear();
  }
  clear_has_detail();
}
inline const ::std::string& Logging::detail() const {
  return *detail_;
}
inline void Logging::set_detail(const ::std::string& value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Logging::set_detail(const char* value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Logging::set_detail(const char* value, size_t size) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logging::mutable_detail() {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  return detail_;
}
inline ::std::string* Logging::release_detail() {
  clear_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_;
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Logging::set_allocated_detail(::std::string* detail) {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    delete detail_;
  }
  if (detail) {
    set_has_detail();
    detail_ = detail;
  } else {
    clear_has_detail();
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Subscribe

// optional string user = 1;
inline bool Subscribe::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Subscribe::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Subscribe::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Subscribe::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Subscribe::user() const {
  return *user_;
}
inline void Subscribe::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Subscribe::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Subscribe::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscribe::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Subscribe::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Subscribe::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 2;
inline bool Subscribe::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Subscribe::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Subscribe::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Subscribe::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Subscribe::type() const {
  return type_;
}
inline void Subscribe::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 value = 3;
inline bool Subscribe::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Subscribe::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Subscribe::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Subscribe::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 Subscribe::value() const {
  return value_;
}
inline void Subscribe::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
}

// optional string topic = 4;
inline bool Subscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Subscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Subscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Subscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Subscribe::topic() const {
  return *topic_;
}
inline void Subscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Subscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Subscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* Subscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Subscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Remove

// optional string user = 1;
inline bool Remove::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Remove::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Remove::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Remove::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Remove::user() const {
  return *user_;
}
inline void Remove::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Remove::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Remove::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Remove::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Remove::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Remove::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 object = 2;
inline bool Remove::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Remove::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Remove::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Remove::clear_object() {
  object_ = GOOGLE_ULONGLONG(0);
  clear_has_object();
}
inline ::google::protobuf::uint64 Remove::object() const {
  return object_;
}
inline void Remove::set_object(::google::protobuf::uint64 value) {
  set_has_object();
  object_ = value;
}

// optional string entity = 5;
inline bool Remove::has_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Remove::set_has_entity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Remove::clear_has_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Remove::clear_entity() {
  if (entity_ != &::google::protobuf::internal::kEmptyString) {
    entity_->clear();
  }
  clear_has_entity();
}
inline const ::std::string& Remove::entity() const {
  return *entity_;
}
inline void Remove::set_entity(const ::std::string& value) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(value);
}
inline void Remove::set_entity(const char* value) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(value);
}
inline void Remove::set_entity(const char* value, size_t size) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Remove::mutable_entity() {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  return entity_;
}
inline ::std::string* Remove::release_entity() {
  clear_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entity_;
    entity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Remove::set_allocated_entity(::std::string* entity) {
  if (entity_ != &::google::protobuf::internal::kEmptyString) {
    delete entity_;
  }
  if (entity) {
    set_has_entity();
    entity_ = entity;
  } else {
    clear_has_entity();
    entity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Property

// optional string user = 1;
inline bool Property::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Property::user() const {
  return *user_;
}
inline void Property::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Property::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Property::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Property::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 object = 2;
inline bool Property::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_object() {
  object_ = GOOGLE_ULONGLONG(0);
  clear_has_object();
}
inline ::google::protobuf::uint64 Property::object() const {
  return object_;
}
inline void Property::set_object(::google::protobuf::uint64 value) {
  set_has_object();
  object_ = value;
}

// optional string name = 3;
inline bool Property::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Property::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Property::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Property::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Property::name() const {
  return *name_;
}
inline void Property::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Property::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 4;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Property::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  return *value_;
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Property::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string entity = 5;
inline bool Property::has_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Property::set_has_entity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Property::clear_has_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Property::clear_entity() {
  if (entity_ != &::google::protobuf::internal::kEmptyString) {
    entity_->clear();
  }
  clear_has_entity();
}
inline const ::std::string& Property::entity() const {
  return *entity_;
}
inline void Property::set_entity(const ::std::string& value) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(value);
}
inline void Property::set_entity(const char* value) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(value);
}
inline void Property::set_entity(const char* value, size_t size) {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  entity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_entity() {
  set_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    entity_ = new ::std::string;
  }
  return entity_;
}
inline ::std::string* Property::release_entity() {
  clear_has_entity();
  if (entity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entity_;
    entity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_entity(::std::string* entity) {
  if (entity_ != &::google::protobuf::internal::kEmptyString) {
    delete entity_;
  }
  if (entity) {
    set_has_entity();
    entity_ = entity;
  } else {
    clear_has_entity();
    entity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Datatype

// optional uint32 type = 11;
inline bool Datatype::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datatype::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datatype::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datatype::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Datatype::type() const {
  return type_;
}
inline void Datatype::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string value = 12;
inline bool Datatype::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datatype::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datatype::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datatype::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Datatype::value() const {
  return *value_;
}
inline void Datatype::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Datatype::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Datatype::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datatype::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Datatype::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datatype::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string range = 13;
inline bool Datatype::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datatype::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datatype::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datatype::clear_range() {
  if (range_ != &::google::protobuf::internal::kEmptyString) {
    range_->clear();
  }
  clear_has_range();
}
inline const ::std::string& Datatype::range() const {
  return *range_;
}
inline void Datatype::set_range(const ::std::string& value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void Datatype::set_range(const char* value) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(value);
}
inline void Datatype::set_range(const char* value, size_t size) {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  range_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datatype::mutable_range() {
  set_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    range_ = new ::std::string;
  }
  return range_;
}
inline ::std::string* Datatype::release_range() {
  clear_has_range();
  if (range_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = range_;
    range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datatype::set_allocated_range(::std::string* range) {
  if (range_ != &::google::protobuf::internal::kEmptyString) {
    delete range_;
  }
  if (range) {
    set_has_range();
    range_ = range;
  } else {
    clear_has_range();
    range_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string detail = 14;
inline bool Datatype::has_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datatype::set_has_detail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datatype::clear_has_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datatype::clear_detail() {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    detail_->clear();
  }
  clear_has_detail();
}
inline const ::std::string& Datatype::detail() const {
  return *detail_;
}
inline void Datatype::set_detail(const ::std::string& value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Datatype::set_detail(const char* value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Datatype::set_detail(const char* value, size_t size) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datatype::mutable_detail() {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  return detail_;
}
inline ::std::string* Datatype::release_detail() {
  clear_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_;
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datatype::set_allocated_detail(::std::string* detail) {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    delete detail_;
  }
  if (detail) {
    set_has_detail();
    detail_ = detail;
  } else {
    clear_has_detail();
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace eco

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Eco_2eproto__INCLUDED
