// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Eco.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Eco_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Eco_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Eco_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Eco_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Eco_2eproto;
namespace eco {
namespace proto {
class Datatype;
struct DatatypeDefaultTypeInternal;
extern DatatypeDefaultTypeInternal _Datatype_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Function;
struct FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class GetLangReq;
struct GetLangReqDefaultTypeInternal;
extern GetLangReqDefaultTypeInternal _GetLangReq_default_instance_;
class GetLicenseRsp;
struct GetLicenseRspDefaultTypeInternal;
extern GetLicenseRspDefaultTypeInternal _GetLicenseRsp_default_instance_;
class Language;
struct LanguageDefaultTypeInternal;
extern LanguageDefaultTypeInternal _Language_default_instance_;
class Locale;
struct LocaleDefaultTypeInternal;
extern LocaleDefaultTypeInternal _Locale_default_instance_;
class Logging;
struct LoggingDefaultTypeInternal;
extern LoggingDefaultTypeInternal _Logging_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class Remove;
struct RemoveDefaultTypeInternal;
extern RemoveDefaultTypeInternal _Remove_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class Subscribe;
struct SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class Word;
struct WordDefaultTypeInternal;
extern WordDefaultTypeInternal _Word_default_instance_;
}  // namespace proto
}  // namespace eco
PROTOBUF_NAMESPACE_OPEN
template<> ::eco::proto::Datatype* Arena::CreateMaybeMessage<::eco::proto::Datatype>(Arena*);
template<> ::eco::proto::Empty* Arena::CreateMaybeMessage<::eco::proto::Empty>(Arena*);
template<> ::eco::proto::Error* Arena::CreateMaybeMessage<::eco::proto::Error>(Arena*);
template<> ::eco::proto::Function* Arena::CreateMaybeMessage<::eco::proto::Function>(Arena*);
template<> ::eco::proto::GetLangReq* Arena::CreateMaybeMessage<::eco::proto::GetLangReq>(Arena*);
template<> ::eco::proto::GetLicenseRsp* Arena::CreateMaybeMessage<::eco::proto::GetLicenseRsp>(Arena*);
template<> ::eco::proto::Language* Arena::CreateMaybeMessage<::eco::proto::Language>(Arena*);
template<> ::eco::proto::Locale* Arena::CreateMaybeMessage<::eco::proto::Locale>(Arena*);
template<> ::eco::proto::Logging* Arena::CreateMaybeMessage<::eco::proto::Logging>(Arena*);
template<> ::eco::proto::Property* Arena::CreateMaybeMessage<::eco::proto::Property>(Arena*);
template<> ::eco::proto::Remove* Arena::CreateMaybeMessage<::eco::proto::Remove>(Arena*);
template<> ::eco::proto::Role* Arena::CreateMaybeMessage<::eco::proto::Role>(Arena*);
template<> ::eco::proto::Subscribe* Arena::CreateMaybeMessage<::eco::proto::Subscribe>(Arena*);
template<> ::eco::proto::Word* Arena::CreateMaybeMessage<::eco::proto::Word>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace eco {
namespace proto {

// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  ~Empty() override;
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eco.proto.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Word final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Word) */ {
 public:
  inline Word() : Word(nullptr) {}
  ~Word() override;
  explicit constexpr Word(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Word(const Word& from);
  Word(Word&& from) noexcept
    : Word() {
    *this = ::std::move(from);
  }

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }
  inline Word& operator=(Word&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Word& default_instance() {
    return *internal_default_instance();
  }
  static inline const Word* internal_default_instance() {
    return reinterpret_cast<const Word*>(
               &_Word_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Word& a, Word& b) {
    a.Swap(&b);
  }
  inline void Swap(Word* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Word* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Word* New() const final {
    return new Word();
  }

  Word* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Word>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Word* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Word";
  }
  protected:
  explicit Word(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Word)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return new Error();
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kValueFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Language final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Language) */ {
 public:
  inline Language() : Language(nullptr) {}
  ~Language() override;
  explicit constexpr Language(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Language(const Language& from);
  Language(Language&& from) noexcept
    : Language() {
    *this = ::std::move(from);
  }

  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }
  inline Language& operator=(Language&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Language& default_instance() {
    return *internal_default_instance();
  }
  static inline const Language* internal_default_instance() {
    return reinterpret_cast<const Language*>(
               &_Language_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Language& a, Language& b) {
    a.Swap(&b);
  }
  inline void Swap(Language* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Language* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Language* New() const final {
    return new Language();
  }

  Language* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Language>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Language* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Language";
  }
  protected:
  explicit Language(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 8,
    kErrorFieldNumber = 9,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // repeated .eco.proto.Word word = 8;
  int word_size() const;
  private:
  int _internal_word_size() const;
  public:
  void clear_word();
  ::eco::proto::Word* mutable_word(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Word >*
      mutable_word();
  private:
  const ::eco::proto::Word& _internal_word(int index) const;
  ::eco::proto::Word* _internal_add_word();
  public:
  const ::eco::proto::Word& word(int index) const;
  ::eco::proto::Word* add_word();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Word >&
      word() const;

  // repeated .eco.proto.Error error = 9;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  ::eco::proto::Error* mutable_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Error >*
      mutable_error();
  private:
  const ::eco::proto::Error& _internal_error(int index) const;
  ::eco::proto::Error* _internal_add_error();
  public:
  const ::eco::proto::Error& error(int index) const;
  ::eco::proto::Error* add_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Error >&
      error() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Language)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Word > word_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Error > error_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Locale final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Locale) */ {
 public:
  inline Locale() : Locale(nullptr) {}
  ~Locale() override;
  explicit constexpr Locale(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Locale(const Locale& from);
  Locale(Locale&& from) noexcept
    : Locale() {
    *this = ::std::move(from);
  }

  inline Locale& operator=(const Locale& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locale& operator=(Locale&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locale& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locale* internal_default_instance() {
    return reinterpret_cast<const Locale*>(
               &_Locale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Locale& a, Locale& b) {
    a.Swap(&b);
  }
  inline void Swap(Locale* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locale* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Locale* New() const final {
    return new Locale();
  }

  Locale* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Locale>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Locale& from);
  void MergeFrom(const Locale& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locale* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Locale";
  }
  protected:
  explicit Locale(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 9,
    kDefaultFieldNumber = 1,
  };
  // repeated .eco.proto.Language lang = 9;
  int lang_size() const;
  private:
  int _internal_lang_size() const;
  public:
  void clear_lang();
  ::eco::proto::Language* mutable_lang(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Language >*
      mutable_lang();
  private:
  const ::eco::proto::Language& _internal_lang(int index) const;
  ::eco::proto::Language* _internal_add_lang();
  public:
  const ::eco::proto::Language& lang(int index) const;
  ::eco::proto::Language* add_lang();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Language >&
      lang() const;

  // string default = 1;
  void clear_default_();
  const std::string& default_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_default_();
  void set_allocated_default_(std::string* default_);
  private:
  const std::string& _internal_default_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_(const std::string& value);
  std::string* _internal_mutable_default_();
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Locale)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Language > lang_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class GetLangReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.GetLangReq) */ {
 public:
  inline GetLangReq() : GetLangReq(nullptr) {}
  ~GetLangReq() override;
  explicit constexpr GetLangReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLangReq(const GetLangReq& from);
  GetLangReq(GetLangReq&& from) noexcept
    : GetLangReq() {
    *this = ::std::move(from);
  }

  inline GetLangReq& operator=(const GetLangReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLangReq& operator=(GetLangReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLangReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLangReq* internal_default_instance() {
    return reinterpret_cast<const GetLangReq*>(
               &_GetLangReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetLangReq& a, GetLangReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLangReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLangReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLangReq* New() const final {
    return new GetLangReq();
  }

  GetLangReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLangReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLangReq& from);
  void MergeFrom(const GetLangReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLangReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.GetLangReq";
  }
  protected:
  explicit GetLangReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
    kLangFieldNumber = 2,
  };
  // string module = 1;
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // string lang = 2;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.GetLangReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class GetLicenseRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.GetLicenseRsp) */ {
 public:
  inline GetLicenseRsp() : GetLicenseRsp(nullptr) {}
  ~GetLicenseRsp() override;
  explicit constexpr GetLicenseRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLicenseRsp(const GetLicenseRsp& from);
  GetLicenseRsp(GetLicenseRsp&& from) noexcept
    : GetLicenseRsp() {
    *this = ::std::move(from);
  }

  inline GetLicenseRsp& operator=(const GetLicenseRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLicenseRsp& operator=(GetLicenseRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLicenseRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLicenseRsp* internal_default_instance() {
    return reinterpret_cast<const GetLicenseRsp*>(
               &_GetLicenseRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetLicenseRsp& a, GetLicenseRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLicenseRsp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLicenseRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLicenseRsp* New() const final {
    return new GetLicenseRsp();
  }

  GetLicenseRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLicenseRsp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLicenseRsp& from);
  void MergeFrom(const GetLicenseRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLicenseRsp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.GetLicenseRsp";
  }
  protected:
  explicit GetLicenseRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
    kLangFieldNumber = 2,
    kLicenseFieldNumber = 4,
    kVersionFieldNumber = 5,
  };
  // string module = 1;
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // string lang = 2;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // string license = 4;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // string version = 5;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.GetLicenseRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Function final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Function) */ {
 public:
  inline Function() : Function(nullptr) {}
  ~Function() override;
  explicit constexpr Function(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Function(const Function& from);
  Function(Function&& from) noexcept
    : Function() {
    *this = ::std::move(from);
  }

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function& operator=(Function&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Function& default_instance() {
    return *internal_default_instance();
  }
  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Function& a, Function& b) {
    a.Swap(&b);
  }
  inline void Swap(Function* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Function* New() const final {
    return new Function();
  }

  Function* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Function>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Function* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Function";
  }
  protected:
  explicit Function(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kNameFieldNumber = 4,
    kDetailFieldNumber = 5,
    kIdFieldNumber = 1,
    kParentFieldNumber = 2,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string detail = 5;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 parent = 2;
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::uint64 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Function)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 parent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  explicit constexpr Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Role* New() const final {
    return new Role();
  }

  Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Role";
  }
  protected:
  explicit Role(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncFieldNumber = 10,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .eco.proto.Function func = 10;
  int func_size() const;
  private:
  int _internal_func_size() const;
  public:
  void clear_func();
  ::eco::proto::Function* mutable_func(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Function >*
      mutable_func();
  private:
  const ::eco::proto::Function& _internal_func(int index) const;
  ::eco::proto::Function* _internal_add_func();
  public:
  const ::eco::proto::Function& func(int index) const;
  ::eco::proto::Function* add_func();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Function >&
      func() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Function > func_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Logging final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Logging) */ {
 public:
  inline Logging() : Logging(nullptr) {}
  ~Logging() override;
  explicit constexpr Logging(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Logging(const Logging& from);
  Logging(Logging&& from) noexcept
    : Logging() {
    *this = ::std::move(from);
  }

  inline Logging& operator=(const Logging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logging& operator=(Logging&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Logging& default_instance() {
    return *internal_default_instance();
  }
  static inline const Logging* internal_default_instance() {
    return reinterpret_cast<const Logging*>(
               &_Logging_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Logging& a, Logging& b) {
    a.Swap(&b);
  }
  inline void Swap(Logging* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logging* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logging* New() const final {
    return new Logging();
  }

  Logging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logging>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logging& from);
  void MergeFrom(const Logging& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logging* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Logging";
  }
  protected:
  explicit Logging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kTimeFieldNumber = 3,
    kIpFieldNumber = 4,
    kMacFieldNumber = 5,
    kNameFieldNumber = 10,
    kValueFieldNumber = 11,
    kDetailFieldNumber = 12,
    kIdFieldNumber = 1,
    kObjectFieldNumber = 9,
    kActionFieldNumber = 8,
  };
  // string user = 2;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string ip = 4;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string mac = 5;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string name = 10;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 11;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string detail = 12;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 object = 9;
  void clear_object();
  ::PROTOBUF_NAMESPACE_ID::uint64 object() const;
  void set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_object() const;
  void _internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 action = 8;
  void clear_action();
  ::PROTOBUF_NAMESPACE_ID::uint32 action() const;
  void set_action(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action() const;
  void _internal_set_action(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Logging)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 object_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Subscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Subscribe) */ {
 public:
  inline Subscribe() : Subscribe(nullptr) {}
  ~Subscribe() override;
  explicit constexpr Subscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscribe(const Subscribe& from);
  Subscribe(Subscribe&& from) noexcept
    : Subscribe() {
    *this = ::std::move(from);
  }

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
               &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Subscribe& a, Subscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Subscribe* New() const final {
    return new Subscribe();
  }

  Subscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subscribe>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Subscribe";
  }
  protected:
  explicit Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kTopicFieldNumber = 4,
    kValueFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string topic = 4;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // uint64 value = 3;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Subscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Remove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Remove) */ {
 public:
  inline Remove() : Remove(nullptr) {}
  ~Remove() override;
  explicit constexpr Remove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Remove(const Remove& from);
  Remove(Remove&& from) noexcept
    : Remove() {
    *this = ::std::move(from);
  }

  inline Remove& operator=(const Remove& from) {
    CopyFrom(from);
    return *this;
  }
  inline Remove& operator=(Remove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Remove& default_instance() {
    return *internal_default_instance();
  }
  static inline const Remove* internal_default_instance() {
    return reinterpret_cast<const Remove*>(
               &_Remove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Remove& a, Remove& b) {
    a.Swap(&b);
  }
  inline void Swap(Remove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Remove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Remove* New() const final {
    return new Remove();
  }

  Remove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Remove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Remove& from);
  void MergeFrom(const Remove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Remove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Remove";
  }
  protected:
  explicit Remove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kEntityFieldNumber = 5,
    kObjectFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string entity = 5;
  void clear_entity();
  const std::string& entity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_entity();
  void set_allocated_entity(std::string* entity);
  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(const std::string& value);
  std::string* _internal_mutable_entity();
  public:

  // uint64 object = 2;
  void clear_object();
  ::PROTOBUF_NAMESPACE_ID::uint64 object() const;
  void set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_object() const;
  void _internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Remove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Property final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Property) */ {
 public:
  inline Property() : Property(nullptr) {}
  ~Property() override;
  explicit constexpr Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property(const Property& from);
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property& operator=(Property&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }
  inline void Swap(Property* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Property* New() const final {
    return new Property();
  }

  Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Property";
  }
  protected:
  explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kNameFieldNumber = 3,
    kValueFieldNumber = 4,
    kEntityFieldNumber = 5,
    kObjectFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string entity = 5;
  void clear_entity();
  const std::string& entity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_entity();
  void set_allocated_entity(std::string* entity);
  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(const std::string& value);
  std::string* _internal_mutable_entity();
  public:

  // uint64 object = 2;
  void clear_object();
  ::PROTOBUF_NAMESPACE_ID::uint64 object() const;
  void set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_object() const;
  void _internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Property)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// -------------------------------------------------------------------

class Datatype final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eco.proto.Datatype) */ {
 public:
  inline Datatype() : Datatype(nullptr) {}
  ~Datatype() override;
  explicit constexpr Datatype(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datatype(const Datatype& from);
  Datatype(Datatype&& from) noexcept
    : Datatype() {
    *this = ::std::move(from);
  }

  inline Datatype& operator=(const Datatype& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datatype& operator=(Datatype&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datatype& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datatype* internal_default_instance() {
    return reinterpret_cast<const Datatype*>(
               &_Datatype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Datatype& a, Datatype& b) {
    a.Swap(&b);
  }
  inline void Swap(Datatype* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datatype* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Datatype* New() const final {
    return new Datatype();
  }

  Datatype* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Datatype>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Datatype& from);
  void MergeFrom(const Datatype& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datatype* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eco.proto.Datatype";
  }
  protected:
  explicit Datatype(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 12,
    kRangeFieldNumber = 13,
    kDetailFieldNumber = 14,
    kTypeFieldNumber = 11,
  };
  // string value = 12;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string range = 13;
  void clear_range();
  const std::string& range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_range();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_range();
  void set_allocated_range(std::string* range);
  private:
  const std::string& _internal_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range(const std::string& value);
  std::string* _internal_mutable_range();
  public:

  // string detail = 14;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint32 type = 11;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:eco.proto.Datatype)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Eco_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Word

// string path = 1;
inline void Word::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Word::path() const {
  // @@protoc_insertion_point(field_get:eco.proto.Word.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Word::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Word.path)
}
inline std::string* Word::mutable_path() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Word.path)
  return _internal_mutable_path();
}
inline const std::string& Word::_internal_path() const {
  return path_.Get();
}
inline void Word::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Word::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Word::release_path() {
  // @@protoc_insertion_point(field_release:eco.proto.Word.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Word::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Word.path)
}

// string value = 2;
inline void Word::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Word::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Word.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Word::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Word.value)
}
inline std::string* Word::mutable_value() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Word.value)
  return _internal_mutable_value();
}
inline const std::string& Word::_internal_value() const {
  return value_.Get();
}
inline void Word::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Word::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Word::release_value() {
  // @@protoc_insertion_point(field_release:eco.proto.Word.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Word::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Word.value)
}

// -------------------------------------------------------------------

// Error

// int32 id = 1;
inline void Error::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::id() const {
  // @@protoc_insertion_point(field_get:eco.proto.Error.id)
  return _internal_id();
}
inline void Error::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void Error::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:eco.proto.Error.id)
}

// string path = 2;
inline void Error::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Error::path() const {
  // @@protoc_insertion_point(field_get:eco.proto.Error.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Error.path)
}
inline std::string* Error::mutable_path() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Error.path)
  return _internal_mutable_path();
}
inline const std::string& Error::_internal_path() const {
  return path_.Get();
}
inline void Error::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_path() {
  // @@protoc_insertion_point(field_release:eco.proto.Error.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Error.path)
}

// string value = 3;
inline void Error::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Error::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Error.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Error.value)
}
inline std::string* Error::mutable_value() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Error.value)
  return _internal_mutable_value();
}
inline const std::string& Error::_internal_value() const {
  return value_.Get();
}
inline void Error::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_value() {
  // @@protoc_insertion_point(field_release:eco.proto.Error.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Error.value)
}

// -------------------------------------------------------------------

// Language

// string name = 1;
inline void Language::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Language::name() const {
  // @@protoc_insertion_point(field_get:eco.proto.Language.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Language::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Language.name)
}
inline std::string* Language::mutable_name() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Language.name)
  return _internal_mutable_name();
}
inline const std::string& Language::_internal_name() const {
  return name_.Get();
}
inline void Language::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Language::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Language::release_name() {
  // @@protoc_insertion_point(field_release:eco.proto.Language.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Language::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Language.name)
}

// string version = 2;
inline void Language::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& Language::version() const {
  // @@protoc_insertion_point(field_get:eco.proto.Language.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Language::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Language.version)
}
inline std::string* Language::mutable_version() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Language.version)
  return _internal_mutable_version();
}
inline const std::string& Language::_internal_version() const {
  return version_.Get();
}
inline void Language::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Language::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Language::release_version() {
  // @@protoc_insertion_point(field_release:eco.proto.Language.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Language::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Language.version)
}

// string path = 3;
inline void Language::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Language::path() const {
  // @@protoc_insertion_point(field_get:eco.proto.Language.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Language::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Language.path)
}
inline std::string* Language::mutable_path() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Language.path)
  return _internal_mutable_path();
}
inline const std::string& Language::_internal_path() const {
  return path_.Get();
}
inline void Language::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Language::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Language::release_path() {
  // @@protoc_insertion_point(field_release:eco.proto.Language.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Language::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Language.path)
}

// repeated .eco.proto.Word word = 8;
inline int Language::_internal_word_size() const {
  return word_.size();
}
inline int Language::word_size() const {
  return _internal_word_size();
}
inline void Language::clear_word() {
  word_.Clear();
}
inline ::eco::proto::Word* Language::mutable_word(int index) {
  // @@protoc_insertion_point(field_mutable:eco.proto.Language.word)
  return word_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Word >*
Language::mutable_word() {
  // @@protoc_insertion_point(field_mutable_list:eco.proto.Language.word)
  return &word_;
}
inline const ::eco::proto::Word& Language::_internal_word(int index) const {
  return word_.Get(index);
}
inline const ::eco::proto::Word& Language::word(int index) const {
  // @@protoc_insertion_point(field_get:eco.proto.Language.word)
  return _internal_word(index);
}
inline ::eco::proto::Word* Language::_internal_add_word() {
  return word_.Add();
}
inline ::eco::proto::Word* Language::add_word() {
  // @@protoc_insertion_point(field_add:eco.proto.Language.word)
  return _internal_add_word();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Word >&
Language::word() const {
  // @@protoc_insertion_point(field_list:eco.proto.Language.word)
  return word_;
}

// repeated .eco.proto.Error error = 9;
inline int Language::_internal_error_size() const {
  return error_.size();
}
inline int Language::error_size() const {
  return _internal_error_size();
}
inline void Language::clear_error() {
  error_.Clear();
}
inline ::eco::proto::Error* Language::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:eco.proto.Language.error)
  return error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Error >*
Language::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:eco.proto.Language.error)
  return &error_;
}
inline const ::eco::proto::Error& Language::_internal_error(int index) const {
  return error_.Get(index);
}
inline const ::eco::proto::Error& Language::error(int index) const {
  // @@protoc_insertion_point(field_get:eco.proto.Language.error)
  return _internal_error(index);
}
inline ::eco::proto::Error* Language::_internal_add_error() {
  return error_.Add();
}
inline ::eco::proto::Error* Language::add_error() {
  // @@protoc_insertion_point(field_add:eco.proto.Language.error)
  return _internal_add_error();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Error >&
Language::error() const {
  // @@protoc_insertion_point(field_list:eco.proto.Language.error)
  return error_;
}

// -------------------------------------------------------------------

// Locale

// string default = 1;
inline void Locale::clear_default_() {
  default__.ClearToEmpty();
}
inline const std::string& Locale::default_() const {
  // @@protoc_insertion_point(field_get:eco.proto.Locale.default)
  return _internal_default_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Locale::set_default_(ArgT0&& arg0, ArgT... args) {
 
 default__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Locale.default)
}
inline std::string* Locale::mutable_default_() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Locale.default)
  return _internal_mutable_default_();
}
inline const std::string& Locale::_internal_default_() const {
  return default__.Get();
}
inline void Locale::_internal_set_default_(const std::string& value) {
  
  default__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Locale::_internal_mutable_default_() {
  
  return default__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Locale::release_default_() {
  // @@protoc_insertion_point(field_release:eco.proto.Locale.default)
  return default__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Locale::set_allocated_default_(std::string* default_) {
  if (default_ != nullptr) {
    
  } else {
    
  }
  default__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Locale.default)
}

// repeated .eco.proto.Language lang = 9;
inline int Locale::_internal_lang_size() const {
  return lang_.size();
}
inline int Locale::lang_size() const {
  return _internal_lang_size();
}
inline void Locale::clear_lang() {
  lang_.Clear();
}
inline ::eco::proto::Language* Locale::mutable_lang(int index) {
  // @@protoc_insertion_point(field_mutable:eco.proto.Locale.lang)
  return lang_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Language >*
Locale::mutable_lang() {
  // @@protoc_insertion_point(field_mutable_list:eco.proto.Locale.lang)
  return &lang_;
}
inline const ::eco::proto::Language& Locale::_internal_lang(int index) const {
  return lang_.Get(index);
}
inline const ::eco::proto::Language& Locale::lang(int index) const {
  // @@protoc_insertion_point(field_get:eco.proto.Locale.lang)
  return _internal_lang(index);
}
inline ::eco::proto::Language* Locale::_internal_add_lang() {
  return lang_.Add();
}
inline ::eco::proto::Language* Locale::add_lang() {
  // @@protoc_insertion_point(field_add:eco.proto.Locale.lang)
  return _internal_add_lang();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Language >&
Locale::lang() const {
  // @@protoc_insertion_point(field_list:eco.proto.Locale.lang)
  return lang_;
}

// -------------------------------------------------------------------

// GetLangReq

// string module = 1;
inline void GetLangReq::clear_module() {
  module_.ClearToEmpty();
}
inline const std::string& GetLangReq::module() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLangReq.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLangReq::set_module(ArgT0&& arg0, ArgT... args) {
 
 module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLangReq.module)
}
inline std::string* GetLangReq::mutable_module() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLangReq.module)
  return _internal_mutable_module();
}
inline const std::string& GetLangReq::_internal_module() const {
  return module_.Get();
}
inline void GetLangReq::_internal_set_module(const std::string& value) {
  
  module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLangReq::_internal_mutable_module() {
  
  return module_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLangReq::release_module() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLangReq.module)
  return module_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLangReq::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  module_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), module,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLangReq.module)
}

// string lang = 2;
inline void GetLangReq::clear_lang() {
  lang_.ClearToEmpty();
}
inline const std::string& GetLangReq::lang() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLangReq.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLangReq::set_lang(ArgT0&& arg0, ArgT... args) {
 
 lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLangReq.lang)
}
inline std::string* GetLangReq::mutable_lang() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLangReq.lang)
  return _internal_mutable_lang();
}
inline const std::string& GetLangReq::_internal_lang() const {
  return lang_.Get();
}
inline void GetLangReq::_internal_set_lang(const std::string& value) {
  
  lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLangReq::_internal_mutable_lang() {
  
  return lang_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLangReq::release_lang() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLangReq.lang)
  return lang_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLangReq::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  lang_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lang,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLangReq.lang)
}

// -------------------------------------------------------------------

// GetLicenseRsp

// string module = 1;
inline void GetLicenseRsp::clear_module() {
  module_.ClearToEmpty();
}
inline const std::string& GetLicenseRsp::module() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLicenseRsp.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLicenseRsp::set_module(ArgT0&& arg0, ArgT... args) {
 
 module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLicenseRsp.module)
}
inline std::string* GetLicenseRsp::mutable_module() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLicenseRsp.module)
  return _internal_mutable_module();
}
inline const std::string& GetLicenseRsp::_internal_module() const {
  return module_.Get();
}
inline void GetLicenseRsp::_internal_set_module(const std::string& value) {
  
  module_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::_internal_mutable_module() {
  
  return module_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::release_module() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLicenseRsp.module)
  return module_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLicenseRsp::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  module_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), module,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLicenseRsp.module)
}

// string lang = 2;
inline void GetLicenseRsp::clear_lang() {
  lang_.ClearToEmpty();
}
inline const std::string& GetLicenseRsp::lang() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLicenseRsp.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLicenseRsp::set_lang(ArgT0&& arg0, ArgT... args) {
 
 lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLicenseRsp.lang)
}
inline std::string* GetLicenseRsp::mutable_lang() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLicenseRsp.lang)
  return _internal_mutable_lang();
}
inline const std::string& GetLicenseRsp::_internal_lang() const {
  return lang_.Get();
}
inline void GetLicenseRsp::_internal_set_lang(const std::string& value) {
  
  lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::_internal_mutable_lang() {
  
  return lang_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::release_lang() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLicenseRsp.lang)
  return lang_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLicenseRsp::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  lang_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lang,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLicenseRsp.lang)
}

// string license = 4;
inline void GetLicenseRsp::clear_license() {
  license_.ClearToEmpty();
}
inline const std::string& GetLicenseRsp::license() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLicenseRsp.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLicenseRsp::set_license(ArgT0&& arg0, ArgT... args) {
 
 license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLicenseRsp.license)
}
inline std::string* GetLicenseRsp::mutable_license() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLicenseRsp.license)
  return _internal_mutable_license();
}
inline const std::string& GetLicenseRsp::_internal_license() const {
  return license_.Get();
}
inline void GetLicenseRsp::_internal_set_license(const std::string& value) {
  
  license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::_internal_mutable_license() {
  
  return license_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::release_license() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLicenseRsp.license)
  return license_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLicenseRsp::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  license_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), license,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLicenseRsp.license)
}

// string version = 5;
inline void GetLicenseRsp::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& GetLicenseRsp::version() const {
  // @@protoc_insertion_point(field_get:eco.proto.GetLicenseRsp.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLicenseRsp::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.GetLicenseRsp.version)
}
inline std::string* GetLicenseRsp::mutable_version() {
  // @@protoc_insertion_point(field_mutable:eco.proto.GetLicenseRsp.version)
  return _internal_mutable_version();
}
inline const std::string& GetLicenseRsp::_internal_version() const {
  return version_.Get();
}
inline void GetLicenseRsp::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetLicenseRsp::release_version() {
  // @@protoc_insertion_point(field_release:eco.proto.GetLicenseRsp.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetLicenseRsp::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.GetLicenseRsp.version)
}

// -------------------------------------------------------------------

// Function

// uint64 id = 1;
inline void Function::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Function::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Function::id() const {
  // @@protoc_insertion_point(field_get:eco.proto.Function.id)
  return _internal_id();
}
inline void Function::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Function::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:eco.proto.Function.id)
}

// uint64 parent = 2;
inline void Function::clear_parent() {
  parent_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Function::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Function::parent() const {
  // @@protoc_insertion_point(field_get:eco.proto.Function.parent)
  return _internal_parent();
}
inline void Function::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  parent_ = value;
}
inline void Function::set_parent(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:eco.proto.Function.parent)
}

// string path = 3;
inline void Function::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& Function::path() const {
  // @@protoc_insertion_point(field_get:eco.proto.Function.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Function.path)
}
inline std::string* Function::mutable_path() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Function.path)
  return _internal_mutable_path();
}
inline const std::string& Function::_internal_path() const {
  return path_.Get();
}
inline void Function::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Function::release_path() {
  // @@protoc_insertion_point(field_release:eco.proto.Function.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Function::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Function.path)
}

// string name = 4;
inline void Function::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Function::name() const {
  // @@protoc_insertion_point(field_get:eco.proto.Function.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Function.name)
}
inline std::string* Function::mutable_name() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Function.name)
  return _internal_mutable_name();
}
inline const std::string& Function::_internal_name() const {
  return name_.Get();
}
inline void Function::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Function::release_name() {
  // @@protoc_insertion_point(field_release:eco.proto.Function.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Function::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Function.name)
}

// string detail = 5;
inline void Function::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& Function::detail() const {
  // @@protoc_insertion_point(field_get:eco.proto.Function.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Function.detail)
}
inline std::string* Function::mutable_detail() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Function.detail)
  return _internal_mutable_detail();
}
inline const std::string& Function::_internal_detail() const {
  return detail_.Get();
}
inline void Function::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Function::release_detail() {
  // @@protoc_insertion_point(field_release:eco.proto.Function.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Function::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Function.detail)
}

// -------------------------------------------------------------------

// Role

// uint64 id = 1;
inline void Role::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Role::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Role::id() const {
  // @@protoc_insertion_point(field_get:eco.proto.Role.id)
  return _internal_id();
}
inline void Role::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Role::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:eco.proto.Role.id)
}

// string name = 2;
inline void Role::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:eco.proto.Role.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Role.name)
}
inline std::string* Role::mutable_name() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Role.name)
  return _internal_mutable_name();
}
inline const std::string& Role::_internal_name() const {
  return name_.Get();
}
inline void Role::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Role::release_name() {
  // @@protoc_insertion_point(field_release:eco.proto.Role.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Role::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Role.name)
}

// repeated .eco.proto.Function func = 10;
inline int Role::_internal_func_size() const {
  return func_.size();
}
inline int Role::func_size() const {
  return _internal_func_size();
}
inline void Role::clear_func() {
  func_.Clear();
}
inline ::eco::proto::Function* Role::mutable_func(int index) {
  // @@protoc_insertion_point(field_mutable:eco.proto.Role.func)
  return func_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Function >*
Role::mutable_func() {
  // @@protoc_insertion_point(field_mutable_list:eco.proto.Role.func)
  return &func_;
}
inline const ::eco::proto::Function& Role::_internal_func(int index) const {
  return func_.Get(index);
}
inline const ::eco::proto::Function& Role::func(int index) const {
  // @@protoc_insertion_point(field_get:eco.proto.Role.func)
  return _internal_func(index);
}
inline ::eco::proto::Function* Role::_internal_add_func() {
  return func_.Add();
}
inline ::eco::proto::Function* Role::add_func() {
  // @@protoc_insertion_point(field_add:eco.proto.Role.func)
  return _internal_add_func();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::eco::proto::Function >&
Role::func() const {
  // @@protoc_insertion_point(field_list:eco.proto.Role.func)
  return func_;
}

// -------------------------------------------------------------------

// Logging

// uint64 id = 1;
inline void Logging::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Logging::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Logging::id() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.id)
  return _internal_id();
}
inline void Logging::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Logging::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:eco.proto.Logging.id)
}

// string user = 2;
inline void Logging::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& Logging::user() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.user)
}
inline std::string* Logging::mutable_user() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.user)
  return _internal_mutable_user();
}
inline const std::string& Logging::_internal_user() const {
  return user_.Get();
}
inline void Logging::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_user() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.user)
}

// string time = 3;
inline void Logging::clear_time() {
  time_.ClearToEmpty();
}
inline const std::string& Logging::time() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_time(ArgT0&& arg0, ArgT... args) {
 
 time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.time)
}
inline std::string* Logging::mutable_time() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.time)
  return _internal_mutable_time();
}
inline const std::string& Logging::_internal_time() const {
  return time_.Get();
}
inline void Logging::_internal_set_time(const std::string& value) {
  
  time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_time() {
  
  return time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_time() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.time)
  return time_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.time)
}

// string ip = 4;
inline void Logging::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Logging::ip() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.ip)
}
inline std::string* Logging::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.ip)
  return _internal_mutable_ip();
}
inline const std::string& Logging::_internal_ip() const {
  return ip_.Get();
}
inline void Logging::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_ip() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.ip)
}

// string mac = 5;
inline void Logging::clear_mac() {
  mac_.ClearToEmpty();
}
inline const std::string& Logging::mac() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_mac(ArgT0&& arg0, ArgT... args) {
 
 mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.mac)
}
inline std::string* Logging::mutable_mac() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.mac)
  return _internal_mutable_mac();
}
inline const std::string& Logging::_internal_mac() const {
  return mac_.Get();
}
inline void Logging::_internal_set_mac(const std::string& value) {
  
  mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_mac() {
  
  return mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_mac() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.mac)
  return mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.mac)
}

// uint32 action = 8;
inline void Logging::clear_action() {
  action_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Logging::_internal_action() const {
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Logging::action() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.action)
  return _internal_action();
}
inline void Logging::_internal_set_action(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  action_ = value;
}
inline void Logging::set_action(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:eco.proto.Logging.action)
}

// uint64 object = 9;
inline void Logging::clear_object() {
  object_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Logging::_internal_object() const {
  return object_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Logging::object() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.object)
  return _internal_object();
}
inline void Logging::_internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  object_ = value;
}
inline void Logging::set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:eco.proto.Logging.object)
}

// string name = 10;
inline void Logging::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Logging::name() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.name)
}
inline std::string* Logging::mutable_name() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.name)
  return _internal_mutable_name();
}
inline const std::string& Logging::_internal_name() const {
  return name_.Get();
}
inline void Logging::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_name() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.name)
}

// string value = 11;
inline void Logging::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Logging::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.value)
}
inline std::string* Logging::mutable_value() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.value)
  return _internal_mutable_value();
}
inline const std::string& Logging::_internal_value() const {
  return value_.Get();
}
inline void Logging::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_value() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.value)
}

// string detail = 12;
inline void Logging::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& Logging::detail() const {
  // @@protoc_insertion_point(field_get:eco.proto.Logging.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Logging::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Logging.detail)
}
inline std::string* Logging::mutable_detail() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Logging.detail)
  return _internal_mutable_detail();
}
inline const std::string& Logging::_internal_detail() const {
  return detail_.Get();
}
inline void Logging::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Logging::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Logging::release_detail() {
  // @@protoc_insertion_point(field_release:eco.proto.Logging.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Logging::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Logging.detail)
}

// -------------------------------------------------------------------

// Subscribe

// string user = 1;
inline void Subscribe::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& Subscribe::user() const {
  // @@protoc_insertion_point(field_get:eco.proto.Subscribe.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Subscribe.user)
}
inline std::string* Subscribe::mutable_user() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Subscribe.user)
  return _internal_mutable_user();
}
inline const std::string& Subscribe::_internal_user() const {
  return user_.Get();
}
inline void Subscribe::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_user() {
  // @@protoc_insertion_point(field_release:eco.proto.Subscribe.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Subscribe.user)
}

// uint32 type = 2;
inline void Subscribe::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::type() const {
  // @@protoc_insertion_point(field_get:eco.proto.Subscribe.type)
  return _internal_type();
}
inline void Subscribe::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void Subscribe::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:eco.proto.Subscribe.type)
}

// uint64 value = 3;
inline void Subscribe::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Subscribe::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Subscribe::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Subscribe.value)
  return _internal_value();
}
inline void Subscribe::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void Subscribe::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:eco.proto.Subscribe.value)
}

// string topic = 4;
inline void Subscribe::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& Subscribe::topic() const {
  // @@protoc_insertion_point(field_get:eco.proto.Subscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Subscribe.topic)
}
inline std::string* Subscribe::mutable_topic() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Subscribe.topic)
  return _internal_mutable_topic();
}
inline const std::string& Subscribe::_internal_topic() const {
  return topic_.Get();
}
inline void Subscribe::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_topic() {
  // @@protoc_insertion_point(field_release:eco.proto.Subscribe.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Subscribe.topic)
}

// -------------------------------------------------------------------

// Remove

// string user = 1;
inline void Remove::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& Remove::user() const {
  // @@protoc_insertion_point(field_get:eco.proto.Remove.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Remove::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Remove.user)
}
inline std::string* Remove::mutable_user() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Remove.user)
  return _internal_mutable_user();
}
inline const std::string& Remove::_internal_user() const {
  return user_.Get();
}
inline void Remove::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Remove::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Remove::release_user() {
  // @@protoc_insertion_point(field_release:eco.proto.Remove.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Remove::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Remove.user)
}

// uint64 object = 2;
inline void Remove::clear_object() {
  object_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Remove::_internal_object() const {
  return object_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Remove::object() const {
  // @@protoc_insertion_point(field_get:eco.proto.Remove.object)
  return _internal_object();
}
inline void Remove::_internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  object_ = value;
}
inline void Remove::set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:eco.proto.Remove.object)
}

// string entity = 5;
inline void Remove::clear_entity() {
  entity_.ClearToEmpty();
}
inline const std::string& Remove::entity() const {
  // @@protoc_insertion_point(field_get:eco.proto.Remove.entity)
  return _internal_entity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Remove::set_entity(ArgT0&& arg0, ArgT... args) {
 
 entity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Remove.entity)
}
inline std::string* Remove::mutable_entity() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Remove.entity)
  return _internal_mutable_entity();
}
inline const std::string& Remove::_internal_entity() const {
  return entity_.Get();
}
inline void Remove::_internal_set_entity(const std::string& value) {
  
  entity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Remove::_internal_mutable_entity() {
  
  return entity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Remove::release_entity() {
  // @@protoc_insertion_point(field_release:eco.proto.Remove.entity)
  return entity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Remove::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    
  } else {
    
  }
  entity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Remove.entity)
}

// -------------------------------------------------------------------

// Property

// string user = 1;
inline void Property::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& Property::user() const {
  // @@protoc_insertion_point(field_get:eco.proto.Property.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Property.user)
}
inline std::string* Property::mutable_user() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Property.user)
  return _internal_mutable_user();
}
inline const std::string& Property::_internal_user() const {
  return user_.Get();
}
inline void Property::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Property::release_user() {
  // @@protoc_insertion_point(field_release:eco.proto.Property.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Property::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Property.user)
}

// uint64 object = 2;
inline void Property::clear_object() {
  object_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Property::_internal_object() const {
  return object_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Property::object() const {
  // @@protoc_insertion_point(field_get:eco.proto.Property.object)
  return _internal_object();
}
inline void Property::_internal_set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  object_ = value;
}
inline void Property::set_object(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:eco.proto.Property.object)
}

// string name = 3;
inline void Property::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Property::name() const {
  // @@protoc_insertion_point(field_get:eco.proto.Property.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Property.name)
}
inline std::string* Property::mutable_name() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Property.name)
  return _internal_mutable_name();
}
inline const std::string& Property::_internal_name() const {
  return name_.Get();
}
inline void Property::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Property::release_name() {
  // @@protoc_insertion_point(field_release:eco.proto.Property.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Property::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Property.name)
}

// string value = 4;
inline void Property::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Property::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Property.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Property.value)
}
inline std::string* Property::mutable_value() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Property.value)
  return _internal_mutable_value();
}
inline const std::string& Property::_internal_value() const {
  return value_.Get();
}
inline void Property::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Property::release_value() {
  // @@protoc_insertion_point(field_release:eco.proto.Property.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Property::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Property.value)
}

// string entity = 5;
inline void Property::clear_entity() {
  entity_.ClearToEmpty();
}
inline const std::string& Property::entity() const {
  // @@protoc_insertion_point(field_get:eco.proto.Property.entity)
  return _internal_entity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_entity(ArgT0&& arg0, ArgT... args) {
 
 entity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Property.entity)
}
inline std::string* Property::mutable_entity() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Property.entity)
  return _internal_mutable_entity();
}
inline const std::string& Property::_internal_entity() const {
  return entity_.Get();
}
inline void Property::_internal_set_entity(const std::string& value) {
  
  entity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_entity() {
  
  return entity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Property::release_entity() {
  // @@protoc_insertion_point(field_release:eco.proto.Property.entity)
  return entity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Property::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    
  } else {
    
  }
  entity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Property.entity)
}

// -------------------------------------------------------------------

// Datatype

// uint32 type = 11;
inline void Datatype::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Datatype::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Datatype::type() const {
  // @@protoc_insertion_point(field_get:eco.proto.Datatype.type)
  return _internal_type();
}
inline void Datatype::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void Datatype::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:eco.proto.Datatype.type)
}

// string value = 12;
inline void Datatype::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Datatype::value() const {
  // @@protoc_insertion_point(field_get:eco.proto.Datatype.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datatype::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Datatype.value)
}
inline std::string* Datatype::mutable_value() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Datatype.value)
  return _internal_mutable_value();
}
inline const std::string& Datatype::_internal_value() const {
  return value_.Get();
}
inline void Datatype::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Datatype::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Datatype::release_value() {
  // @@protoc_insertion_point(field_release:eco.proto.Datatype.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Datatype::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Datatype.value)
}

// string range = 13;
inline void Datatype::clear_range() {
  range_.ClearToEmpty();
}
inline const std::string& Datatype::range() const {
  // @@protoc_insertion_point(field_get:eco.proto.Datatype.range)
  return _internal_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datatype::set_range(ArgT0&& arg0, ArgT... args) {
 
 range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Datatype.range)
}
inline std::string* Datatype::mutable_range() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Datatype.range)
  return _internal_mutable_range();
}
inline const std::string& Datatype::_internal_range() const {
  return range_.Get();
}
inline void Datatype::_internal_set_range(const std::string& value) {
  
  range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Datatype::_internal_mutable_range() {
  
  return range_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Datatype::release_range() {
  // @@protoc_insertion_point(field_release:eco.proto.Datatype.range)
  return range_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Datatype::set_allocated_range(std::string* range) {
  if (range != nullptr) {
    
  } else {
    
  }
  range_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), range,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Datatype.range)
}

// string detail = 14;
inline void Datatype::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& Datatype::detail() const {
  // @@protoc_insertion_point(field_get:eco.proto.Datatype.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datatype::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:eco.proto.Datatype.detail)
}
inline std::string* Datatype::mutable_detail() {
  // @@protoc_insertion_point(field_mutable:eco.proto.Datatype.detail)
  return _internal_mutable_detail();
}
inline const std::string& Datatype::_internal_detail() const {
  return detail_.Get();
}
inline void Datatype::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Datatype::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Datatype::release_detail() {
  // @@protoc_insertion_point(field_release:eco.proto.Datatype.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Datatype::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:eco.proto.Datatype.detail)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace eco

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Eco_2eproto
